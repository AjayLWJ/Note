## linux文件系统与设备文件

​		由于字符设备和块设备都良好地体现了“一切都是文件”的设计思想，首先，驱动最终通过与文件操作相关的系统调用或C库函数（本质山也基于系统调用）被访问，而设备驱动的结构最终也是为了迎合提供给应用程序员的API。其次，驱动工程师在设备驱动中不可避免地会与设备文件系统打交道，包括从linux2.4内核的devfs文件系统到linux2.6以后的udev。

### linux文件操作

#### 1. 文件操作系统调用

​	linux的文件操作系统调用涉及创建、打开、读写和关闭文件。

- 创建

  ```c
  int create(const char *filename, mode_t mode);
  ```

  ​		参数`mode`指定新建文件的存取权限，它同`umask`一起决定文件的最终权限（`mode&umask`），其中，`umask`代表了文件在创建时需要去掉的一些存取权限。

- 打开

  ```c
  int open(const char *pathname, int flags);
  int open(const char *pathname, int flags, mode_t mode);
  ```

  ​		其中`pathname`是要打开的文件名（包含路径名称，缺省是认为在当前路径下面），`flags`可以是表中的一个或几个的组合。

  |   标志    |                        含义                         |
  | :-------: | :-------------------------------------------------: |
  | O_RDONLY  |                以只读的方式打开文件                 |
  | O_WRONLY  |                以只写的方式打开文件                 |
  |  O_RDWR   |               以只读写的方式打开文件                |
  | O_APPEND  |                以追加的方式打开文件                 |
  |  O_CREAT  |                    创建一个文件                     |
  |  O_EXEC   | 如果使用了O_CREAT而且文件已经存在，就会发生一个错误 |
  | O_NOBLOCK |             以非阻塞的方式打开一个文件              |
  |  O_TRUNC  |         如果文件已经存在，则删除文件的内容          |

  ​		O_RDONLY、O_WRONLY、O_RDWR三个标志只能使用任意的一个。如果使用了O_CREAT标志，则使用的函数是`int open(const char *pathname, int flags, mode_t mode)`；这个时候还要指定`mode`标志，以表示文件的访问权限。

  |  标志   |         含义         |
  | :-----: | :------------------: |
  | S_IRUSR |      用户可以读      |
  | S_IWUSR |      用户可以写      |
  | S_IXUSR |     用户可以执行     |
  | S_IRWXU | 用户可以读、写、执行 |
  | S_IRGRP |       组可以读       |
  | S_IWGRP |       组可以写       |
  | S_IXGRP |      组可以执行      |
  | S_IRWXG |  组可以读、写、执行  |
  | S_IROTH |      其他可以读      |
  | S_IWOTH |      其他可以写      |
  | S_IXOTH |     其他可以执行     |
  | S_IRWXO | 其他可以读、写、执行 |
  | S_ISUID |   设置用户的执行ID   |
  | S_ISGID |    设置组的执行ID    |

  ​		除了可以通过上述宏进行“或”逻辑产生标志外，也可以自己用数字来表示，linux用5个数字来表示文件的各种权限：第一位表示设置用户ID；第二位表示设置组ID；第三位表示用户自己的权限位；第四位表示组的权限；最后一位表示其他人的权限。

  ​		例如，要创建一个用户可读可写可执行，但组没有权限，其他人可读可执行的文件，并设置用户ID位，那么应该使用的模式是1（设置用户ID）、0（不设置组ID）、7（1+2+4，读写执行），0（没有权限）、5（1+4，读执行）即10 705；

- 读写

- 定位

- 关闭

  

#### 2. C库文件操作

待补充。。。。

### linux文件系统

#### 1. linux文件系统目录结构

#### 2. linux文件系统与设备驱动

![文件系统与设备驱动之间的关系](.\image\文件系统与设备驱动之间的关系.png)

​		上图为linux中**虚拟文件系统vfs**、磁盘/flash文件系统及一般的设备与设备驱动程序之间的关系。

​		应用程序和VFS之间的接口是系统调用，而VFS与文件系统以及设备文件系统之间的接口是`file_operation`结构体成员函数，这个结构体包含对文件进行打开、关闭、读写、控制的一系列成员函数，如下图所示。

![image-20200604103947561](.\image\应用程序、VFS与设备驱动.png)

​		由于字符设备的上层没有类似于磁盘的ext2等文件系统，所以字符设备的`file_operation`正是字符设备驱动的核心。

​		块设备有两种访问方法，一种方法是不通过文件系统直接访问裸设备，在linux内核实现了统一的`def_blk_fops`这一`file_operation`，它的源码位于`fs/block_dev.c`，所以当运行类似于`"dd if=/dev/sdb1 of=sdb1,img"`的命令把整个`/dev/sdb1`裸分区复制到`sdb1.img`的时候，内核走的是`def_blk_fops`这个`file_operation`；另外一种方法是通过文件系统来访问块设备，`file_operation`的实现则位于文件系统内，文件系统会把针对文件的读写转换为针对块设备原始扇区的读写。

​		在设备驱动程序的设计中，一般而言，会关心`file`和`inode`这两个结构体。

- ##### file结构体

  `	file`结构体代表一个打开的文件，**系统中每个打开的文件在内核空间都有一个关联的`struct file`**。它由内核在打开文件时创建，并传递给在文件上进行操作的任何函数。在文件的所有实例都关闭后，内核释放这个数据结构。

  在内核和驱动源代码中，`struct file`的指针通常被命名为`file`或`filp`。

- ##### inode结构体

  `VFS inode`包含文件访问权限、属主、组、大小、生成时间、访问时间、最后修改时间等信息。它是linux管理文件系统的最基本单位，也是文件系统连接任何子目录、文件的桥梁。

  对于表示设备文件的`inode`结构，`dev_t i_rdev`字段包含设备编号。linux内核设备编号分为主设备号和次设备号，前者为`dev_t`的高12位，后者为`dev_t`的低20位。

  下列操作作用于从一个`inode`中获得主设备号和次设备号。

  ```c
  unsigned int iminor(struct inode *inode);
  unsigned int imajor(struct inode *inode);
  ```

  查看`/proc/devices`文件可以获知系统中注册的设备。

  主设备号是与驱动对应的概念，同一类设备一般使用相同的主设备号，不同类的设备一般使用不同的主设备号（但是也不排除在同一主设备号下包含有一定差异的设备）。因为同一驱动可支持多个同类设备，因此用此设备号来描述该驱动的设备序号。序号一般从0开始。

### 设备文件系统devfs（被抛弃了）

​		`devfs`是由linux2.4内核引入的，它的出现使得设备驱动程序能自主地管理自己的设备文件，并有以下优点：

- 可以通过程序在设备初始化时，在`/dev`目录下创建设备文件，卸载设备时将它删除。
- 设备驱动程序可以指定设备名、所有者和权限位，用户空间程序可以修改所有者和权限位。
- 不再需要为设备驱动程序分配主设备号以及处理次设备号，在程序中可以直接给`register_chrdev()`传递0主设备号以获得可用的主设备号，并在`devfs_register()`中指定次设备号。

### udev用户空间设备管理

​		在linux2.6内核中，`devfs`被认为是过时的方法，并最终被抛弃了，udev取代了它。

​		linux2.6以后的内核引入了**`sysfs`文件系统(/sys)**，`sysfs`被看成是与`proc devfs和devoty`同类别的文件系统，该文件系统是一个虚拟的文件系统，它可以产生一个**包括所有系统硬件的层级视图**，与提供进程和状态信息的`proc`文件系统十分类似。

​		`sysfs`把连接在系统上的设备和总线组织成为一个分级的文件，它们可以由用户空间存储，向用户空间导出内核数据结构以及它们的属性。`sysfs`的一个目的就是展示设备驱动模型中各组件的层次关系，其顶级目录包括`block bus dev devices class fs kernel power和firmware`等。

​		`block `目录包含所有的块设备；`devices`目录包含系统的所有设备，并根据设备挂接的总线类型组织成层次结构；`bus`目录包含系统中所有的总线类型；`class`目录包含系统中的设备类型（如网卡设备、声卡设备、输入设备等）。





### 总结：

​		linux用户空间的文件编程有两种方法，即通过linux API和通过C库函数访问文件。**用户空间看不到设备驱动，能看到的只有与设备对应的文件，因此文件编程也就是用户空间的设备编程**。

​		linux按照功能对文件系统的目录结构进行了良好的规划。`/dev`是设备文件的存放目录，`devfs`和`udev`分别是linux2.4和linux2.6以后的内核生成设备文件节点的方法，前者运行于内核空间，后者运行于用户空间。

​		linux2.6以后的内核通过一系列数据结构定义了设备模型，设备模型与`sysfs`文件系统中的目录和文件存在一种对应关系。设备和驱动分离，并通过总线进行匹配。

​		`udev`可以利用内核通过`netlink`发出的`uevent`信息动态创建设备文件节点。